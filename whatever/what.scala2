import scala.util.parsing.combinator.syntactical._
import scala.util.parsing.combinator.lexical._

sealed abstract class Expr {
	def eval(): Int
	def _toString(): String
}

case class EInt(value: Int) extends Expr {
	def eval(): Int = value
	def _toString = eval.toString
}

case class ESum(a: List[Expr]) extends Expr {
	def eval: Int = a.foldLeft(0)(_ + _.eval)
	def _toString(): String = "whut"
}

object ExprParser extends StandardTokenParsers {
	/*
	def what[T, U](p: Parser[T], q: Parser[U], r: Parser[U]): Parser[List[T]] = {
		p~rep(q~> p) ^^ { case s~st => s :: st}
	}
	*/

	lexical.delimiters ++= List("+", "-")
	def litteral = numericLit ^^ {s => EInt(s.toInt)}
	// def obj
//	def sum : Parser[List[EInt]] = repsep(litteral, "+") ^^ {s => List() ++ s}

	def sum : Parser[ESum] = {
//		repsep(litteral, "+") ^^ {s => ESum(s)}}
		what(litteral, "+") ^^ {s => ESum(s)}}
//		repsep(litteral, "-") ^^ {s => ESum(s)}}
//		repsep(litteral~"+"|litteral~"-") ^^ {s => ESum(s)}}
		
		

	def expr = (sum|litteral)

	def parse(s: String) = {
		val tokens = new lexical.Scanner(s)
		phrase(expr)(tokens)
	}
	
	def apply(s: String): Expr = {
		parse(s) match {
			case Success(tree, _) => tree
			case e: NoSuccess =>
				throw new IllegalArgumentException("you dun goofd" + s)
		}
	}
}
